9개의 명령어를 가지고 있는 VM이다. 

실제 문제에서는 9개의 명령어를 사용하지는 않는다.

```
DF 01 XX YY | MEMORY[XX] = YY
DF 02 XX YY | swap(MEMORY[XX], MEMORY[YY])
DF 03 XX YY | MEMORY[XX]+= YY
DF 04 XX YY | MEMORY[XX]+= MEMORY[YY]
DF 05 XX YY | MEMORY[XX]-= YY
DF 06 XX YY | MEMORY[XX]-= MEMORY[YY]
DF 07 XX YY ZZ | strncmp(MEMORY[XX],MEMORY[YY],ZZ) 다를 경우 프로그램 종료
DF 08 XX YY | write(1,XX,YY)
DF 09 XX YY | read(0,XX,YY)
```

다음과 같은 구조의 명령어를 가지고 있다.

첫 번째 바이트는 값은 DF로 고정되어 있어야 하며

두 번째 바이트는 명령어를 지정해주는 opcode 역할을 한다.

세 번쨰 바이트 이후부터는 오퍼랜드에 해당한다.

DF 바이트 값은 기준으로 끊어서 계산하면 편하게 program 파일을 분석할 수 있을 것이다.

```
df01 0048 | MEMORY[0x00] = 0x48
df01 0165 | MEMORY[0x01] = 0x65
df01 026c | MEMORY[0x02] = 0x6C
df01 036c | MEMORY[0x03] = 0x6C
df01 046f | ...
df01 0520 | ...
df01 0657 | ...
df01 076f | ...
df01 0872 | ...
df01 096c | ...
df01 0a64 | ...
df01 0b21 | ...
df08 0010 | write(1,MEMORY[0x00],0x10)
df01 1049 | MEMORY[0x10] = 0x49
df01 116e | MEMORY[0x11] = 0x6e
df01 1270 | ...
df01 1375 | ...
df01 1474 | ...
df01 1520 | ...
df01 164b | ...
df01 1745 | ...
df01 1859 | ...
df01 193a | ...
df08 1010 | write(1,MEMORY[0x10],0x10)
df09 2010 | read(0,MEMORY[0x20],0x10)
df02 202f | swap(MEMORY[0x20],MEMORY[0x2F])
df02 212e | swap(MEMORY[0x21],MEMORY[0x2e])
df02 292a | swap(MEMORY[0x29],MEMORY[0x2a])
df03 2205 | MEMORY[0x22] += 0x5
df05 2702 | MEMORY[0x27] -= 0x2
df03 2b07 | MEMORY[0x2b] += 0x7
df03 2525 | MEMORY[0x25] += 0x25
df05 2630 | MEMORY[0x26] -= 0x30
df01 3021 | MEMORY[0x30] = 0x21
df01 3121 | MEMORY[0x31] = 0x21
df01 3235 | MEMORY[0x32] = 0x35
df01 3364 | ...
df01 345f | ...
df01 3567 | ...
df01 3649 | ...
df01 3730 | ...
df01 385f | ...
df01 3940 | ...
df01 3a57 | ...
df01 3b39 | ...
df01 3c4c | ...
df01 3d64 | ...
df01 3e30 | ...
df01 3f67 | ...
df07 203010 | strncmp(MEMORY[0x20],MEMORY[0x30],0x10)
df01 4043 | MEMORY[0x40] = 0x43
df01 416f | MEMORY[0x41] = 0x6f
df01 4272 | MEMORY[0x42] = 0x72
df01 4372 | ...
df01 4465 | ...
df01 4563 | ...
df01 4674 | ...
df01 4721 | ...
df08 4010 | write(1,MEMORY[0x40],0x10)
```

다음과 같이 코드를 해석할 수 있다.

중요하게 살펴봐야 할 점은 `strncmp(MEMORY[0x20],MEMORY[0x30],0x10)` 부분이다.

MEMORY[0x20~0x30] 부분은 우리가 입력하는 문자열이고 문자열을 입력한 다음

여러 연산들에 의해서 바뀌게 된다. 그리고 MEMORY[0x30~0x40] 까지의 값들은 대입하는걸 확인할 수 있다.

역연산을 할 경우 `g00d_By2_W@2Ld!!` 문자열을 입력해야 `Correct!` 문자열이 출력되는 것을 확인할 수 있다.

`KCTF{g00d_By2_W@2Ld!!}`

